# 背包动态规划（Knapsack DP）

### 问题原型

给定容量为 $m$ 的背包和 $n$ 件物品（第 $i$ 件物品重量为 $w_i$，价值为 $v_i$），求不超过背包容量的最大价值。

**说明**：状态转移方程中 $dp[i][j]$ 表示前 $i$ 件物品，容量为 $j$ 的背包中，最大价值为 $dp[i][j]$

### 1. 0/1 背包

**特点**：每件物品**只能选或不选**

**状态转移方程**：

```math
dp[i][j] = \max(dp[i-1][j], dp[i-1][j-w_i] + v_i)
```

**滚动数组优化**：

```cpp
for (int i = 1; i <= n; i++) {
    for (int j = m; j >= w[i]; j--) {
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]); // 逆序遍历，防止一个物品被重复选取
    }
}
```

### 2. 完全背包

**特点**：每件物品**可以选无限次**

**状态转移方程**：

```math
dp[i][j] = \max(dp[i-1][j], dp[i][j-w_i] + v_i)
```

```cpp
for (int i = 1; i <= n; i++) {
    for (int j = w[i]; j <= m; j++) {
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]); //正序遍历
    }
}
```

### 3. 多重背包

**特点**：第 $i$ 件物品最多选 $s_i$ 次

```cpp

```
